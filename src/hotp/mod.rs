/// Default layer to generate a HOTP
/// # Arguments
///
/// * `digest` - Byte digest generated by hashing the secret key
///
pub fn generate_default(
    digest: Vec<u8>
) -> String {
    generate(None, digest)
}


/// Generates a HOTP
///
/// # Arguments
///
/// * `digits` - Optional parameter that defines the length of the one time pad (default: 6)
/// * `digest` - Byte digest generated by hashing the secret key
///
pub fn generate(
    digits: Option<u32>,
    digest:  Vec<u8>, // Assume the digest is generated correctly. I don't like the cyclical nature that speakeasy has generateHotp -> digest -> generateHotp. Thoughts?
) -> String {
    let defined_digits = match digits {
        Some(d) => d,
        None => 6
    };

    let offset = match digest.last() {
        Some(o) => o & 0xf,
        None => 0 // 0 & 0xf == 0
    };

    /*
    This section works to fill up the unsigned 32 bit number by:
    1.  Taking the 8 bits at the offset from the digest, AND'ing with 0x7f so that we can ignore the sign bit
        and then bit shifting 24 to the left to fill the most significant bits.
    2.  Taking the next 8 bits from the digest at (offset + 1), AND'ing with 0xff to get the set bits, shifting 16 to fill
        the next 8 significant bits.
    3.  Same as (2.) but taking the bits from (offset + 2)
    4.  Same as (2.) but taking the bits from (offset + 3)
    5.  OR'ing each of these u32 so that we collapse all of the set bits into one u32
     */
    let f_msg = "Failed to pull from digest.";
    let code = 
        (u32::from(digest.get(offset as usize).expect(f_msg) & 0x7f) << 24) | 
        (u32::from(digest.get((offset + 1) as usize).expect(f_msg) & 0xff) << 16) |
        (u32::from(digest.get((offset + 2) as usize).expect(f_msg) & 0xff) << 8) |
        (u32::from(digest.get((offset + 3) as usize).expect(f_msg) & 0xff));

    let padded_string = format!("{:0>width$}", code.to_string(), width=defined_digits as usize);
    (&padded_string[(padded_string.len() - defined_digits as usize)..padded_string.len()]).to_string()
}

pub fn verify() {}
pub fn verify_delta() {}


#[cfg(test)]
mod hotp_tests {
    use crate::hotp::generate;
    use crate::{digest, generate_secret_default, Algorithm};

    #[test]
    fn test_generate_hotp_default() {
        let secret_key = generate_secret_default();
        let digest = match digest(secret_key.ascii, 0, Algorithm::Sha512) {
            Ok(d) => d,
            _ => vec!()
        };
        let hotp = generate(None, digest);
        assert_eq!(hotp.len(), 6);
    }

    #[test]
    fn test_generate_hotp_custom_length() {
        let secret_key = generate_secret_default();
        let digest = match digest(secret_key.ascii, 0, Algorithm::Sha512) {
            Ok(d) => d,
            _ => vec!()
        };
        let hotp = generate(Some(50), digest);
        assert_eq!(hotp.len(), 50);
    }
}